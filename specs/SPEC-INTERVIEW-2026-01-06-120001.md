# TalkFlow Modern Swift/SwiftUI Migration Spec

**Interview Date:** 2026-01-06
**Topic:** Migration to modern Swift patterns (@Observable, @MainActor, Swift 6 strict concurrency, macOS 15+ APIs)

---

## 1. Overview

This document captures the requirements and technical decisions for migrating TalkFlow from legacy SwiftUI patterns (ObservableObject, @Published, @StateObject, @ObservedObject) to modern Swift/SwiftUI patterns using the Observation framework, structured concurrency, and macOS 15+ APIs.

### Scope

- Migrate all `ObservableObject` classes to `@Observable`
- Replace `@Published` with direct property observation
- Replace `@EnvironmentObject` with `@Environment` and custom environment keys
- Replace `@StateObject`/`@ObservedObject` with `@State` and `@Bindable`
- Migrate GRDB operations to async APIs
- Enable Swift 6 strict concurrency checking
- Bump minimum deployment target to macOS 15 (Sequoia)
- Modernize UI components with macOS 15+ APIs

---

## 2. Requirements

### Explicit Requirements

1. **Use @Observable macro** for all observable model classes
2. **Use @State ownership** in views for model references
3. **Use @Bindable** for passing observable objects to child views that need bindings
4. **Use @Environment** with custom keys for dependency injection
5. **Avoid ObservableObject, @ObservedObject, @StateObject, @Published** in new code
6. **Target macOS 15+** minimum deployment
7. **Enable Swift 6 strict concurrency** checking
8. **Add Sendable conformance** to all value types and immutable models

### Implicit Requirements

1. Maintain all existing functionality through the migration
2. Keep test coverage intact and update test patterns
3. Maintain backwards compatibility with existing user data (SQLite database)
4. Preserve API key storage in Keychain
5. Documentation (CLAUDE.md) must be updated with new patterns and rationale

---

## 3. Technical Decisions

### 3.1 Threading Model

**Decision:** Selective @MainActor isolation

- Published/observable properties that drive UI are marked with `@MainActor`
- Background work (database operations, audio processing) remains off main thread
- Explicit isolation rather than whole-class `@MainActor` to avoid blocking

**Rationale:** Provides control over what runs where, prevents accidental main thread blocking during database or audio operations.

### 3.2 Dependency Injection Pattern

**Decision:** Hybrid approach with SwiftUI App + AppDelegate

- **UI-facing models** (@Observable): Owned by views via `@State`, passed down via `@Environment`
- **Background services** (ShortcutManager, AudioCaptureService core): Owned by AppDelegate
- **Communication**: AppDelegate creates @Observable models, passes to TalkFlowApp scene via environment
- Both can access shared observable state

**Rationale:** Menu bar apps need services running independent of any view lifecycle. ShortcutManager must operate even with no windows open.

### 3.3 GRDB Database Operations

**Decision:** Full async migration

- All database methods become `async throws`
- Use GRDB's async `read {}` and `write {}` APIs
- Callers use `Task {}` and `await` for database operations
- Errors propagate via throws, no more fire-and-forget

**Rationale:** Aligns with modern Swift concurrency, enables proper error handling, makes code more predictable.

### 3.4 Service-View Communication

**Decision:** Shared via Environment

- AppDelegate creates @Observable model instances
- Models are injected into the SwiftUI environment
- Both AppDelegate-owned services and views can access the same observable instances
- No NotificationCenter or Combine publishers needed for state synchronization

**Rationale:** Type-safe, integrates well with SwiftUI's observation system, single source of truth.

### 3.5 Testability

**Decision:** Protocol + concrete implementation

- Keep protocols for services (e.g., `HistoryStorageProtocol`)
- @Observable concrete classes conform to protocols
- Mocks remain protocol-based, don't need @Observable
- Existing test infrastructure preserved

**Rationale:** Maintains clean DI and testability without requiring @Observable mocks.

### 3.6 Audio Real-Time Requirements

**Decision:** Hybrid with TaskGroup

- Audio buffer capture stays on dedicated serial DispatchQueue for predictable latency
- Actor-based coordination for state management
- UI-facing properties (`audioLevel`, `isRecording`) isolated to @MainActor
- AVAudioEngine callbacks don't touch actors directly

**Rationale:** Audio callbacks are time-sensitive; GCD provides more predictable timing than structured concurrency.

### 3.7 Configuration Model

**Decision:** Keep struct + didSet

- `AppConfiguration` remains a Codable struct
- `ConfigurationManager` becomes @Observable class
- `didSet` on configuration property triggers save to UserDefaults
- Views use `@Bindable` to bind to configuration properties via key paths

**Rationale:** Keeps persistence simple (Codable struct), while enabling fine-grained observation.

### 3.8 ShortcutManager

**Decision:** Keep callback-based CGEvent tap

- CGEvent tap callbacks remain callback-based (C API requirement)
- Callbacks invoke `@MainActor`-isolated methods to trigger state changes
- No AsyncStream wrapper needed; events are discrete triggers, not streams to iterate

**Rationale:** CGEvent API is inherently callback-based; wrapping adds complexity without benefit.

### 3.9 Error Handling

**Decision:** Throwing async with indicator feedback

- Database and network methods are `async throws`
- Failed history saves show brief error state in status indicator
- Errors logged via Logger for debugging
- No silent failures for operations that affect user data

**Rationale:** Users should know if their transcription wasn't saved. Indicator provides non-intrusive feedback.

### 3.10 Sendable & Swift 6

**Decision:** Enable strict concurrency mode

- Enable Swift 6 strict concurrency checking
- Add explicit `Sendable` conformance to all value types
- Fix all concurrency warnings properly (no `@unchecked Sendable` shortcuts)
- Models like `TranscriptionRecord`, `AudioDevice`, `ShortcutConfiguration` become Sendable

**Rationale:** Prepares codebase for Swift 6, ensures thread safety is compiler-verified.

### 3.11 macOS 15+ API Adoption

**Decision:** UI-focused modernization

- Modernize UI components (Menu styling, Settings views) with macOS 15+ APIs
- Infrastructure code (database, audio, networking) only updated if there are specific benefits
- Not a comprehensive audit of all deprecated APIs, but address obvious improvements

**Rationale:** Balances modernization effort with practical benefit; UI is most visible.

### 3.12 Migration Strategy

**Decision:** Big bang migration

- Single branch/PR that migrates everything at once
- Ensures consistency across the codebase
- No partial states where some code uses old patterns and some uses new
- Tests migrated alongside production code

**Rationale:** ObservableObject/Observable patterns don't mix well; incremental migration creates compile-time friction.

---

## 4. Data Model

### Existing Models (No Schema Changes)

The SQLite schema remains unchanged:

```sql
transcriptions (
  id TEXT PRIMARY KEY,
  text TEXT NOT NULL,
  timestamp DATETIME NOT NULL,
  duration_ms INTEGER,
  confidence REAL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
)
```

### Model Type Updates

```swift
// Before
struct TranscriptionRecord: Codable, FetchableRecord, PersistableRecord { ... }

// After - add Sendable
struct TranscriptionRecord: Codable, FetchableRecord, PersistableRecord, Sendable { ... }
```

All value types need explicit Sendable:
- `TranscriptionRecord`
- `AudioDevice`
- `ShortcutConfiguration`
- `AppConfiguration`
- `IndicatorState`
- `TranscriptionResult`

---

## 5. User Flows

### Recording Flow (Updated)

1. User presses trigger key
2. ShortcutManager (CGEvent callback) calls `@MainActor`-isolated method
3. Method starts async Task to begin recording
4. AudioCaptureService updates `@MainActor` `isRecording` property
5. StatusIndicatorView observes change via @Observable, updates UI
6. User releases key → async processing chain begins
7. On completion, `historyStorage.save()` called (async throws)
8. If save fails, indicatorStateManager updates to error state briefly

### Settings Flow (Updated)

1. User opens Settings window
2. View receives ConfigurationManager via `@Environment`
3. View uses `@Bindable` to create bindings to nested configuration properties
4. Changes trigger didSet, which saves to UserDefaults
5. Other views observing ConfigurationManager see updates immediately

---

## 6. Edge Cases

### Database Save Failure

- **Scenario:** SQLite write fails (disk full, permissions, corruption)
- **Handling:** Error thrown, caught in Task, indicator shows error briefly, logged
- **User sees:** Status indicator flashes error state for 2-3 seconds
- **Data:** Transcription text was already pasted (successful), only history storage failed

### Audio Device Disconnection During Recording

- **Scenario:** User unplugs USB microphone while recording
- **Handling:** Current behavior preserved - cancel recording, notify user
- **Migration impact:** None; error handling path unchanged

### Concurrent Configuration Access

- **Scenario:** Settings window open while recording triggers config read
- **Handling:** @MainActor isolation ensures single-threaded access to configuration
- **Migration impact:** More explicit threading model makes this safer

### App Launch With No Windows

- **Scenario:** App launches, sits in menu bar, no settings/history windows open
- **Handling:** AppDelegate owns ShortcutManager, keeps it alive
- **Migration impact:** Hybrid ownership model preserves this

---

## 7. Error Handling

### Error Types & User Feedback

| Error | Source | User Feedback | Logged |
|-------|--------|---------------|--------|
| Microphone permission denied | AudioCaptureService | Indicator error + prompt | Yes |
| Accessibility permission denied | ShortcutManager | Indicator error + prompt | Yes |
| API key missing | OpenAIWhisperService | Indicator error | Yes |
| API request failed (network) | OpenAIWhisperService | Indicator error after 3 retries | Yes |
| History save failed | HistoryStorage | Indicator error (brief) | Yes |
| No speech detected | AudioProcessor | "No speech" indicator | No |
| Audio engine creation failed | AudioCaptureService | Indicator error | Yes |

### Error Propagation Pattern

```swift
// Old pattern
func save(_ record: TranscriptionRecord) {
    do {
        try dbQueue?.write { db in ... }
    } catch {
        Logger.shared.error("Failed: \(error)")
        // Silent failure
    }
}

// New pattern
func save(_ record: TranscriptionRecord) async throws {
    try await dbQueue?.write { db in ... }
    // Caller handles error, can update indicator
}
```

---

## 8. Open Questions

None remaining - all major technical decisions have been made.

---

## 9. Out of Scope

The following are explicitly **not** part of this migration:

1. **Local Whisper support** (Phase 2 feature)
2. **Custom terms dictionary UI** (separate feature)
3. **New features** - this is a refactoring migration only
4. **Database schema changes** - existing data must continue to work
5. **API changes** - external API (OpenAI) interactions unchanged
6. **Xcode project structure** - keep Package.swift-based structure

---

## 10. Implementation Notes

### File-by-File Migration Checklist

#### Core Services (@Observable migration)

- [ ] `ConfigurationManager.swift` - ObservableObject → @Observable, keep didSet
- [ ] `HistoryStorage.swift` - ObservableObject → @Observable, async methods
- [ ] `AudioCaptureService.swift` - ObservableObject → @Observable, hybrid threading
- [ ] `IndicatorStateManager.swift` - (new file or existing) → @Observable

#### Models (Sendable conformance)

- [ ] `TranscriptionRecord.swift` - add Sendable
- [ ] `ShortcutConfiguration.swift` - add Sendable
- [ ] `Configuration.swift` (AppConfiguration) - add Sendable
- [ ] `TranscriptionResult.swift` - add Sendable
- [ ] `AudioDevice` in AudioCaptureService - add Sendable

#### Views (@Environment migration)

- [ ] `TalkFlowApp.swift` - own @State models, inject via environment
- [ ] `HistoryListView.swift` - @EnvironmentObject → @Environment
- [ ] `GeneralSettingsView.swift` - @EnvironmentObject → @Environment + @Bindable
- [ ] `AudioSettingsView.swift` - @EnvironmentObject → @Environment + @Bindable
- [ ] `TranscriptionSettingsView.swift` - @EnvironmentObject → @Environment + @Bindable
- [ ] `AppearanceSettingsView.swift` - @EnvironmentObject → @Environment + @Bindable
- [ ] `MenuBarMenu.swift` - update if using observed objects
- [ ] `StatusIndicatorView.swift` - @EnvironmentObject → @Environment

#### App Infrastructure

- [ ] `AppDelegate.swift` - coordinate with TalkFlowApp, own background services
- [ ] `DependencyContainer.swift` - possibly remove or simplify
- [ ] `Package.swift` - bump macOS target to 15

#### Tests

- [ ] `HistoryStorageTests.swift` - update for async methods
- [ ] `MockKeychainService.swift` - ensure protocol conformance works
- [ ] `MockAudioCaptureService.swift` - update for new interface
- [ ] `MockTranscriptionService.swift` - update for async
- [ ] All tests - use async test methods where needed

### Environment Key Pattern

```swift
// Define environment key
private struct HistoryStorageKey: EnvironmentKey {
    static let defaultValue: HistoryStorage? = nil
}

extension EnvironmentValues {
    var historyStorage: HistoryStorage? {
        get { self[HistoryStorageKey.self] }
        set { self[HistoryStorageKey.self] = newValue }
    }
}

// In TalkFlowApp
@main
struct TalkFlowApp: App {
    @State private var historyStorage = HistoryStorage()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(\.historyStorage, historyStorage)
        }
    }
}

// In views
struct HistoryListView: View {
    @Environment(\.historyStorage) private var historyStorage
    // ...
}
```

### @Observable Service Pattern

```swift
import Observation

@Observable
final class ConfigurationManager {
    var configuration: AppConfiguration {
        didSet { save() }
    }

    @MainActor
    var someUIProperty: String = ""

    init() {
        configuration = Self.load()
    }

    private static func load() -> AppConfiguration { ... }
    private func save() { ... }
}
```

### Async GRDB Pattern

```swift
@Observable
final class HistoryStorage: HistoryStorageProtocol {
    private var dbQueue: DatabaseQueue?

    @MainActor
    private(set) var recentRecords: [TranscriptionRecord] = []

    func save(_ record: TranscriptionRecord) async throws {
        try await dbQueue?.write { db in
            try record.insert(db)
        }
        await loadRecentRecords()
    }

    @MainActor
    private func loadRecentRecords() async {
        recentRecords = await fetchRecent()
    }

    func fetchRecent(limit: Int = 5) async -> [TranscriptionRecord] {
        do {
            return try await dbQueue?.read { db in
                try TranscriptionRecord
                    .order(Column("timestamp").desc)
                    .limit(limit)
                    .fetchAll(db)
            } ?? []
        } catch {
            Logger.shared.error("Failed to fetch: \(error)")
            return []
        }
    }
}
```

### CLAUDE.md Updates

Add to CLAUDE.md under a new "## Swift Patterns" section:

```markdown
## Swift Patterns

### Observable Models
Prefer modern SwiftUI/Observation macros:
- Use `@Observable` for observable model classes
- Use `@State` for view ownership of observable objects
- Use `@Bindable` in views that need bindings to observable objects
- Use `@Environment` with custom keys for dependency injection

**Avoid:** `ObservableObject`, `@Published`, `@StateObject`, `@ObservedObject`, `@EnvironmentObject`

**Rationale:** The Observation framework provides more efficient updates (fine-grained observation), cleaner syntax, and aligns with Apple's direction for SwiftUI.

### Concurrency
- Use `async/await` for asynchronous operations
- Mark UI-updating properties with `@MainActor`
- Enable Swift 6 strict concurrency checking
- Add `Sendable` conformance to value types crossing actor boundaries
- Keep real-time audio callbacks on dedicated DispatchQueues for latency predictability

### macOS Target
- Minimum deployment: macOS 15 (Sequoia)
- Leverage macOS 15+ APIs for UI components where beneficial
```

---

## Summary

This migration modernizes TalkFlow's Swift patterns while preserving all functionality. Key changes:

1. **@Observable** replaces ObservableObject across all services
2. **Async/await** for all database operations via GRDB async APIs
3. **Hybrid ownership** - AppDelegate for background services, SwiftUI @State for UI models
4. **Swift 6 strict concurrency** enabled with proper Sendable conformance
5. **macOS 15** minimum deployment target
6. **Big bang migration** in a single PR with tests updated alongside

The migration improves code clarity, thread safety, and positions the codebase for future Swift evolution.
